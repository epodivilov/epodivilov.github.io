<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>7 + 1 способ анимировать спиннер</title>
  <link rel="stylesheet" href="styles/index.css" />
</head>

<body class="layout">
  <main>
    <article>
      <h1>7 + 1 способ анимировать спиннер</h1>
      <p>Многие недолюбливают <abbr title="спиннеры">бесконечные индикаторы загрузки</abbr>, потому что по ним не
        видно реального прогресса выполнения задачи. Мне кажется, вывести какой-то спиннер пользователю и уведомить,
        что работа идет и результат ожидается, намного лучше, чем ничего.</p>
      <p>Иногда спиннер вместо того, чтобы успокоить пользователя, тормозит и забирает больше ресурсов, чем сама
        задача. Про один такой индикатор я и расскажу.</p>
      <!--  -->
      <h2 id="с-чего-мы-начинали">С чего мы начинали<a class="anchor" href="#с-чего-мы-начинали">#</a></h2>
      <p>Однажды при открытии нескольких SPA-приложений разом, топовый Макбук завыл. Мы провели расследование и
        выяснили, что причиной стал обычный спиннер:</p>
      <img src="./assets/image-01.svg" width="50%" style="margin: 0 auto; display: block" />
      <p>Оказалось, что на него тратилось почти 10% ресурсов CPU! Мне стало интересно разобраться и все оптимизировать и
        я погрузился в код. </p>
      <blockquote>
        <p>Все представленные замеры производились на следующей конфигурации: Google Chrome версии 95.0.4638.54; macOS
          Big Sur 11.6; MacBook Pro 15 Mid 2015, Intel Core i7 2.2Ghz, 16Gb DDR3;</p>
      </blockquote>
      <!--  -->
      <h2 id="react">Решение первое: React<a class="anchor" href="#react">#</a></h2>
      <p>Я начал с решения на React. Каждый цикл анимации вычислял значения, устанавливал их в стейт компонента, а затем
        использовал в render-функции. Каждые 16 мс запускались те механизмы React, за которые разработчики его так
        «любят». Не самое хорошее решение.</p>
      <iframe height="300" style="width: 100%" scrolling="no" title="react-spinner"
        src="https://codepen.io/epodivilov/embed/preview/MWEbvXG?default-tab=html%2Cresult" frameborder="no"
        loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href="https://codepen.io/epodivilov/pen/MWEbvXG"> react-spinner</a> by Podivilov Evgeniy (<a
          href="https://codepen.io/epodivilov">@epodivilov</a>) on <a href="https://codepen.io">CodePen</a>.
      </iframe>
      <p>React выполняет много работы, это видно на графике одного цикла анимации во вкладке Performance. Но каждое
        следующее состояние анимации отличается от предыдущего, поэтому все механизмы React`а по предотвращению лишних
        ре-рендеров бессмысленны. Нужно каждый раз отрисовывать новое состояние.
      </p>
      <figure>
        <img src="./assets/react-001.png" width="100%" style="margin: 0 auto; display: block" />
        <figcaption>Цикл анимации на react (<a
            href="https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=https://epodivilov.github.io/eight-ways-animate-spinner/assets/profile-react.json">подробнее</a>)
        </figcaption>
      </figure>
      <p>Кроме проблем с лишней работой бывают проблемы с потреблением памяти. График показывает сначала рост, а затем
        обрыв — освобождение неиспользуемой памяти. И такое происходит часто.</p>
      <figure>
        <img src="./assets/react-002.png" width="100%" style="margin: 0 auto; display: block" />
        <figcaption>Потребление памяти на react (<a
            href="https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=https://epodivilov.github.io/eight-ways-animate-spinner/assets/profile-react.json">подробнее</a>)
        </figcaption>
      </figure>
      <p>Я подумал, что где-то подтекает память, потом присмотрелся к графику и увидел, что потребление памяти всегда
        находится в каком-то константном диапазоне и на протяжении работы приложения не выходит за его рамки. В коде мы
        обнаружим такую конструкцию:</p>
      <script src="https://gist.github.com/epodivilov/66221fa939e55e6237c4124d2d132054.js"></script>
      <p>Массив colorTable хранит 10 константных значений. Его инициализация находится внутри функции анимации, поэтому
        мы создаем этот массив в каждом цикле, каждые 16 мс. Каждую секунду мы создаем десятки новых массивов и это не
        очень хорошо.</p>
      <p>JS — язык с автоматическим управлением памятью. Это значит, разработчикам не надо задумываться над выделением
        памяти при создании чего-либо. Память выделяется автоматически, когда появляется массив, и память освобождается
        автоматически, когда мы больше не используем его.</p>
      <p>
        За процесс определения неиспользуемой памяти и ее освобождение отвечает <addr title="GC">Garbage Collector
        </addr>. Процесс определения неиспользуемой памяти трудозатратный для компьютера и, чтобы минимизировать влияние
        на работу страницы, браузеры периодически запускают GC.Когда очень быстро создаются массивы, достигается некий
        предел, после которого браузер запускает GC и высвобождает всю неиспользуемую память. Потом все повторяется.
      </p>
      <blockquote>
        Подробнее про GC на примере Chrome можно прочитать на <a href="https://v8.dev/blog/trash-talk">v8.dev</a>
      </blockquote>
      <!--  -->
      <h2 id="svg-js">Решение второе: SVG + JS<a class="anchor" href="#svg-js">#</a></h2>
      <p>Сначала избавимся от React, чтобы избежать лишней работы и упростить график производительности.</p>
      <iframe height="300" style="width: 100%" scrolling="no" title="svg-js-spinner"
        src="https://codepen.io/epodivilov/embed/preview/Jjrbywq?default-tab=html%2Cresult" frameborder="no"
        loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href="https://codepen.io/epodivilov/pen/Jjrbywq"> svg-js-spinner</a> by Podivilov Evgeniy (<a
          href="https://codepen.io/epodivilov">@epodivilov</a>) on <a href="https://codepen.io">CodePen</a>.
      </iframe>
      <p>Теперь на вкладке Performance цикл анимации выглядит проще, но не значительно лучше: self time задачи
        уменьшилось до 0,17 мс с 1,55 мс, но общее время снизилось только до 4,69 мс против 5,69 мс в версии с React.
      </p>
      <figure>
        <img src="./assets/svg-js-001.png" width="100%" style="margin: 0 auto; display: block" />
        <figcaption>Цикл анимации на svg + js (<a
            href="https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=https://epodivilov.github.io/eight-ways-animate-spinner/assets/profile-svg-js.json">подробнее</a>)
        </figcaption>
      </figure>
      <p>Проблемы с памятью уменьшились, но не исчезли. Если воспользоваться вкладкой Memory и сравнить heap snapshot до
        и после принудительного вызова GC, можно локализовать проблему памяти в недрах функции lerpColor, а точнее — в
        конкатенации строк во время формирования цвета.</p>
      <figure>
        <img src="./assets/svg-js-002.png" width="100%" style="margin: 0 auto; display: block" />
        <figcaption>Потребление памяти svg + js (<a
            href="https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=https://epodivilov.github.io/eight-ways-animate-spinner/assets/profile-svg-js.json">подробнее</a>)
        </figcaption>
      </figure>
      <p>Как и в предыдущем примере значительную часть цикла анимации занимают задачи пересчета стилей и ре-лайаута.
        Наша анимация работает в рамках пайплайна отрисовки в браузерах.</p>
      <p>С помощью JS меняем стили элемента path, что вызывает этап style. За ним вызывается layout, дальше paint и
        composite. Можно оптимизировать этот пайплайн и пропустить некоторые шаги, если использовать свойства,
        подходящие для анимаций . Например, пропустить этапы layout и paint, если анимация основана только на свойстве
        transform.</p>
      <p>Сделать такую анимацию только на transform, кажется, не получится? Чтобы сделать анимацию быстрой, нужно все
        писать на canvas.</p>
      <!--  -->
      <h2 id="canvas">Решение третье: Canvas<a class="anchor" href="#canvas">#</a></h2>
      <p>Перепишем все на canvas. У него нет элементов и стилей. Меняя что-то, мы отрисовываем это на холсте без лишних
        этапов. Немного низкоуровнево, но мы же хотим лучшей производительности!</p>
      <iframe height="300" style="width: 100%" scrolling="no" title="canvas-spinner"
        src="https://codepen.io/epodivilov/embed/preview/OJxbjem?default-tab=html%2Cresult" frameborder="no"
        loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href="https://codepen.io/epodivilov/pen/OJxbjem"> canvas-spinner</a> by Podivilov Evgeniy (<a
          href="https://codepen.io/epodivilov">@epodivilov</a>) on <a href="https://codepen.io">CodePen</a>.
      </iframe>
      <p>Выглядит неплохо, но замеры по-прежнему выдают не фантастические результаты. Рекалькуляции и ре-лайаута теперь
        нет, но много времени мы на этом не выиграли.</p>
      <figure>
        <img src="./assets/canvas-001.png" width="100%" style="margin: 0 auto; display: block" />
        <figcaption>Цикл анимации на canvas (<a
            href="https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=https://epodivilov.github.io/eight-ways-animate-spinner/assets/profile-canvas.json">подробнее</a>)
        </figcaption>
      </figure>
      <p>Недостаток решения, как и предыдущих, — оно работает в главном потоке. JS — однопоточный язык и когда в главном
        потоке выполняется задача, до ее окончания мы перейдем к другим задачам. Если пришла тяжелая и блокирующая
        задача, то обновление состояния индикатора просто не выполнится и пользователь может заметить подтормаживание
        анимации, а то и полную остановку.</p>
      <video src="./assets/freeze-01.mov" width="100%" style="margin: 0 auto; display: block" autoplay loop muted
        playsinline controls></video>
      <p>Есть возможность распараллелить выполнение задач через web worker`ы. Но в них нет доступа к DOM, а значит мы не
        сможем менять состояния элементов. И я решил избавиться от JS.</p>
      <!--  -->
      <h2 id="svg-css">Решение четвертое: SVG + CSS<a class="anchor" href="#svg-css">#</a></h2>
      <p>Я вернулся к SVG, но переписал все на чистом CSS и попытался сделать анимацию менее зависимой от основного
        потока. Результат кажется более простым для понимания: вместо сложных вычислений сдвига и цвета мы задаем лишь
        опорные точки, а все расчеты по интерполяции значений между этими точками берет на себя браузер. Разработчики
        браузеров наверняка сделали эти вещи оптимальнее, чем мы со своими велосипедами.</p>
      <iframe height="300" style="width: 100%" scrolling="no" title="svg-css-spinner"
        src="https://codepen.io/epodivilov/embed/preview/bGoBobo?default-tab=html%2Cresult" frameborder="no"
        loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href="https://codepen.io/epodivilov/pen/bGoBobo"> svg-css-spinner</a> by Podivilov Evgeniy (<a
          href="https://codepen.io/epodivilov">@epodivilov</a>) on <a href="https://codepen.io">CodePen</a>.
      </iframe>
      <p>Результаты улучшились, но проблема с фризами анимации осталась. Не все свойства CSS анимируются в отдельном
        потоке. В CSS можно анимировать с высокой производительностью только два свойства —- transform и opacity. Зато с
        памятью теперь проблем нет.</p>
      <figure>
        <img src="./assets/svg-css-001.png" width="100%" style="margin: 0 auto; display: block" />
        <figcaption>Цикл анимации на svg + css (<a
            href="https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=https://epodivilov.github.io/eight-ways-animate-spinner/assets/profile-svg-css.json">подробнее</a>)
        </figcaption>
      </figure>
      <figure>
        <img src="./assets/svg-css-002.png" width="100%" style="margin: 0 auto; display: block" />
        <figcaption>Потребление памяти на svg + css (<a
            href="https://chromedevtools.github.io/timeline-viewer/?loadTimelineFromURL=https://epodivilov.github.io/eight-ways-animate-spinner/assets/profile-svg-css.json">подробнее</a>)
        </figcaption>
      </figure>
      <!--  -->
      <h2 id="svg">Решение пятое: SVG<a class="anchor" href="#svg">#</a></h2>
      <p>Я отказался от JS, получится ли отказаться и от CSS?</p>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/SVG_animation_with_SMIL">SMIL</a> — это Synchronized
        Multimedia Integration Language, такой HTML для анимаций. Можно запрограммировать
        анимации в виде разметки с помощью набора тегов и атрибутов. Можно изменить код так, что вся анимация будет
        только в SVG-файле.</p>
      <iframe height="300" style="width: 100%" scrolling="no" title="svg-spinner"
        src="https://codepen.io/epodivilov/embed/preview/PoJbJom?default-tab=html%2Cresult" frameborder="no"
        loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href="https://codepen.io/epodivilov/pen/PoJbJom"> svg-spinner</a> by Podivilov Evgeniy (<a
          href="https://codepen.io/epodivilov">@epodivilov</a>) on <a href="https://codepen.io">CodePen</a>.
      </iframe>
      <p>Без JS. Без CSS. Работает практически везде, кроме IE. Такую анимацию можно подключить с помощью тега или
        свойства background-image. Но блокировка основного треда по-прежнему блокирует нашу анимацию.</p>
      <!--  -->
      <h2 id="video">Решение шестое: Video<a class="anchor" href="#video">#</a></h2>
      <p>Видео кажется отличной идеей и имеет ряд преимуществ:</p>
      <ul>
        <li>расчеты всех этапов анимации выполняются заранее и «зашиваются» в видео,</li>
        <li>поддерживается всеми браузерами,</li>
        <li>существуют аппаратные оптимизации для некоторых видео кодеков.</li>
      </ul>
      <p>Все, что нам нужно — записать небольшой ролик и циклически воспроизводить его.</p>
      <video src="./assets/transparent-video-example.mov" width="100%" style="margin: 0 auto; display: block" autoplay
        loop muted playsinline controls></video>
      <pre>
&lt;video width=&quot;100%&quot; height=&quot;100%&quot; autoplay loop muted playsinline&gt;
  &lt;source src=&quot;spinner.mov&quot; type=&#39;video/mp4; codecs=&quot;hvc1&quot;&#39; /&gt;
  &lt;source src=&quot;spinner.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;/video&gt;
</pre>
      <p>Но есть и несколько минусов:</p>
      <ul>
        <li>Нужен прозрачный фон. Даже если не надо поддерживать IE 11, все равно нужно минимум два варианта видео: с
          кодеком VP9 (для Chrome) и HEVC (для Safari). </li>
        <li>Менять размеры видео без потери в качестве не получится. Значит нужно несколько видеофайлов под каждый
          размер спиннера. </li>
        <li>Перезапуск видео выполняется в основном потоке, хотя само видео выполняется в отдельном. Спиннер будет
          крутиться пока не проиграет один цикл анимации.</li>

      </ul>
      <video src="./assets/transparent-video-freeze-example.mov" width="100%" style="margin: 0 auto; display: block"
        autoplay loop muted playsinline controls></video>
      <!--  -->
      <h2 id="css">Решение седьмое: CSS<a class="anchor" href="#css">#</a></h2>
      <p>Но если подумать, что такое видео? Набор кадров которые очень быстро переключаются. Что, если использовать
        именно это качество в CSS?</p>
      <p>Звучит как бред, но раз я решил пробовать все варианты, то почему бы и нет. С помощью <del>черной магии</del>
        ffmpeg
        разложил видео покадрово, а с image magic собрал атлас из полученных кадров. Главное, чтобы фон был прозрачным.
        С помощью простых и быстрых CSS-трансформаций я менял кадры:</p>
      <iframe height="300" style="width: 100%" scrolling="no" title="css-spinner"
        src="https://codepen.io/epodivilov/embed/preview/MWEJYKm?default-tab=html%2Cresult" frameborder="no"
        loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href="https://codepen.io/epodivilov/pen/MWEJYKm"> css-spinner</a> by Podivilov Evgeniy (<a
          href="https://codepen.io/epodivilov">@epodivilov</a>) on <a href="https://codepen.io">CodePen</a>.
      </iframe>
      <p>Сработало! Даже при условии, что основной поток занят JS`ом. Да, по-прежнему есть проблемы с ресайзом, но их
        можно решить с помощью нескольких атласов. Мы даже можем подгружать атлас на сайт с использованием lazy
        атрибута. Кажется, я нашел идеальное решение.</p>
      <!--  -->
      <h2 id="выводы">Выводы<a class="anchor" href="#выводы">#</a></h2>
      <p>Кроме разных способов анимации я хотел показать, что в большинстве случаев нам достаточно простых, но быстрых
        решений. Даже создатели популярной библиотеки компонентов material-ui пошли по пути сокращения потребления
        ресурсов и в пользу UX.</p>
      <p>Надеюсь, смогу помочь кому-то убедить коллег/дизайнеров/бизнес потратить ресурсы на что-то более важное, чем
        вычурные индикаторы загрузки.</p>
      <p>Решения рабочие, но использовать их в продакшене крайне сомнительно. Для обычного спиннера слишком много
        затрат. В итоге нам удалось убедить дизайнеров и бизнес, что будет лучше заменить наш вычурный индикатор на
        что-то попроще. Например, такое:</p>
      <iframe height="300" style="width: 100%" scrolling="no" title="Untitled"
        src="https://codepen.io/epodivilov/embed/preview/wvrgBeM?default-tab=html%2Cresult" frameborder="no"
        loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href="https://codepen.io/epodivilov/pen/wvrgBeM"> Untitled</a> by Podivilov Evgeniy (<a
          href="https://codepen.io/epodivilov">@epodivilov</a>) on <a href="https://codepen.io">CodePen</a>.
      </iframe>
    </article>
  </main>
</body>

</html>
